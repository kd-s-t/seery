<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seer - AI Prediction Market on BNB Chain</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 14px;
        }

        .wallet-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .wallet-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        button {
            background: #667eea;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #5568d3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .markets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .market-card {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .market-card:hover {
            transform: translateY(-2px);
        }

        .market-question {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 15px;
        }

        .market-outcomes {
            margin-bottom: 15px;
        }

        .outcome {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            margin: 5px 0;
            background: #f5f5f5;
            border-radius: 5px;
        }

        .outcome-label {
            font-weight: 500;
        }

        .outcome-pool {
            color: #667eea;
            font-weight: bold;
        }

        .bet-section {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .bet-input {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        input[type="number"] {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .market-status {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .status-active {
            background: #d4edda;
            color: #155724;
        }

        .status-resolved {
            background: #f8d7da;
            color: #721c24;
        }

        .ai-badge {
            background: #e7f3ff;
            color: #0066cc;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            display: inline-block;
            margin-left: 10px;
        }

        .create-market-section {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }

        input[type="text"], textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        textarea {
            min-height: 80px;
            resize: vertical;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }

        .success {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>ðŸ¤– AI Prediction Market</h1>
            <p class="subtitle">Powered by BNB Chain â€¢ AI-Assisted Market Creation & Resolution</p>
        </header>

        <div class="wallet-section">
            <div class="wallet-info">
                <div>
                    <strong>Wallet:</strong> <span id="wallet-address">Not connected</span>
                </div>
                <button id="connect-wallet-btn">Connect Wallet</button>
            </div>
        </div>

        <div id="messages"></div>

        <div class="create-market-section">
            <h2>Create New Market</h2>
            <form id="create-market-form">
                <div class="form-group">
                    <label>Question</label>
                    <input type="text" id="market-question" placeholder="Will Bitcoin reach $100k by end of 2024?" required>
                </div>
                <div class="form-group">
                    <label>Outcomes (comma-separated)</label>
                    <input type="text" id="market-outcomes" placeholder="Yes, No" required>
                </div>
                <div class="form-group">
                    <label>Duration (hours)</label>
                    <input type="number" id="market-duration" value="72" min="1" max="168" required>
                </div>
                <button type="submit">Create Market</button>
                <button type="button" id="ai-generate-btn" style="margin-left: 10px; background: #28a745;">ðŸ¤– Generate with AI</button>
            </form>
        </div>

        <h2 style="color: white; margin-bottom: 15px;">Active Markets</h2>
        <div id="markets-container" class="markets-grid">
            <div class="loading">Loading markets...</div>
        </div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-6.9.0.umd.min.js"></script>
    <script>
        let userAddress = null;
        let markets = [];

        // Check if MetaMask is installed
        function checkMetaMask() {
            if (typeof window.ethereum === 'undefined') {
                showMessage('Please install MetaMask to use this app', 'error');
                return false;
            }
            return true;
        }

        // Connect wallet
        document.getElementById('connect-wallet-btn').addEventListener('click', async () => {
            if (!checkMetaMask()) return;

            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                userAddress = accounts[0];
                document.getElementById('wallet-address').textContent = 
                    userAddress.substring(0, 6) + '...' + userAddress.substring(38);
                showMessage('Wallet connected!', 'success');
                loadMarkets();
            } catch (error) {
                showMessage('Failed to connect wallet: ' + error.message, 'error');
            }
        });

        // Create market on-chain
        document.getElementById('create-market-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (!userAddress) {
                showMessage('Please connect your wallet first', 'error');
                return;
            }

            if (typeof window.ethereum === 'undefined') {
                showMessage('MetaMask is required to create markets', 'error');
                return;
            }

            const question = document.getElementById('market-question').value;
            const outcomes = document.getElementById('market-outcomes').value.split(',').map(s => s.trim());
            const duration = parseInt(document.getElementById('market-duration').value);

            if (outcomes.length < 2) {
                showMessage('At least 2 outcomes are required', 'error');
                return;
            }

            try {
                // Get contract address
                if (!contractAddress) {
                    const configResponse = await fetch('/api/config');
                    const config = await configResponse.json();
                    contractAddress = config.contractAddress;
                    
                    if (!contractAddress) {
                        showMessage('Contract not deployed. Please deploy contract first.', 'error');
                        return;
                    }
                }

                // Connect to contract via MetaMask
                const provider = new ethers.BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();
                const contract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);

                showMessage('Confirm transaction in MetaMask...', 'success');

                // Create market on-chain
                const tx = await contract.createMarket(question, outcomes, duration);
                
                showMessage(`Transaction sent! Hash: ${tx.hash}`, 'success');
                showMessage('Waiting for confirmation...', 'success');

                // Wait for confirmation
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    // Extract market ID from event
                    const event = receipt.logs.find(log => {
                        try {
                            const parsed = contract.interface.parseLog(log);
                            return parsed && parsed.name === 'MarketCreated';
                        } catch {
                            return false;
                        }
                    });
                    
                    let marketId = null;
                    if (event) {
                        const parsed = contract.interface.parseLog(event);
                        marketId = parsed.args.marketId.toString();
                    }
                    
                    showMessage(`Market created successfully! ID: ${marketId || 'pending'}`, 'success');
                    document.getElementById('create-market-form').reset();
                    loadMarkets();
                } else {
                    showMessage('Transaction failed', 'error');
                }
            } catch (error) {
                if (error.code === 4001) {
                    showMessage('Transaction rejected by user', 'error');
                } else {
                    showMessage('Error: ' + error.message, 'error');
                }
            }
        });

        // AI Generate markets
        document.getElementById('ai-generate-btn').addEventListener('click', async () => {
            try {
                const response = await fetch('/api/ai/generate-markets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ topic: 'cryptocurrency', count: 3 })
                });

                const data = await response.json();
                if (data.success && data.markets.length > 0) {
                    const market = data.markets[0];
                    document.getElementById('market-question').value = market.question;
                    document.getElementById('market-outcomes').value = market.outcomes.join(', ');
                    document.getElementById('market-duration').value = market.durationHours || 72;
                    showMessage('AI generated market suggestion!', 'success');
                }
            } catch (error) {
                showMessage('Error generating market: ' + error.message, 'error');
            }
        });

        // Load markets
        async function loadMarkets() {
            try {
                const response = await fetch('/api/markets');
                const data = await response.json();
                
                if (data.success) {
                    markets = data.markets;
                    renderMarkets();
                }
            } catch (error) {
                document.getElementById('markets-container').innerHTML = 
                    '<div class="error">Error loading markets: ' + error.message + '</div>';
            }
        }

        // Render markets
        function renderMarkets() {
            const container = document.getElementById('markets-container');
            
            if (markets.length === 0) {
                container.innerHTML = '<div class="loading">No markets yet. Create one above!</div>';
                return;
            }

            container.innerHTML = markets.map(market => `
                <div class="market-card">
                    <div class="market-status ${market.resolved ? 'status-resolved' : 'status-active'}">
                        ${market.resolved ? 'Resolved' : 'Active'}
                    </div>
                    <div class="market-question">${market.question}</div>
                    <div class="market-outcomes">
                        ${market.outcomes.map((outcome, idx) => `
                            <div class="outcome">
                                <span class="outcome-label">${outcome}</span>
                                <span class="outcome-pool">
                                    ${market.outcomePools && market.outcomePools[idx] 
                                        ? market.outcomePools[idx].total.toFixed(4) + ' BNB' 
                                        : '0 BNB'}
                                </span>
                            </div>
                        `).join('')}
                    </div>
                    ${!market.resolved ? `
                        <div class="bet-section">
                            <strong>Place Bet:</strong>
                            <div class="bet-input">
                                <select id="outcome-${market.market_id}" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">
                                    ${market.outcomes.map((outcome, idx) => 
                                        `<option value="${idx}">${outcome}</option>`
                                    ).join('')}
                                </select>
                                <input type="number" id="amount-${market.market_id}" placeholder="0.01" step="0.001" min="0.001" style="flex: 1;">
                                <button onclick="placeBet(${market.market_id})">Bet</button>
                            </div>
                        </div>
                    ` : `
                        <div style="color: #666; font-size: 14px; margin-top: 10px;">
                            Winner: <strong>${market.outcomes[market.winning_outcome]}</strong>
                        </div>
                    `}
                </div>
            `).join('');
        }

        // Contract ABI (minimal - just what we need)
        const CONTRACT_ABI = [
            "function createMarket(string question, string[] outcomes, uint256 durationHours) returns (uint256)",
            "function placeBet(uint256 marketId, uint256 outcome) payable",
            "function getMarket(uint256 marketId) view returns (address creator, string question, uint256 endTime, bool resolved, uint256 winningOutcome, uint256 totalPool)",
            "function getMarketOutcomes(uint256 marketId) view returns (string[])",
            "function getOutcomePool(uint256 marketId, uint256 outcome) view returns (uint256)",
            "event MarketCreated(uint256 indexed marketId, address indexed creator, string question)"
        ];
        
        let contractAddress = null; // Will be set from API or env

        // Place bet - sends BNB from MetaMask to contract
        async function placeBet(marketId) {
            if (!userAddress) {
                showMessage('Please connect your wallet first', 'error');
                return;
            }

            if (typeof window.ethereum === 'undefined') {
                showMessage('MetaMask is required to place bets', 'error');
                return;
            }

            const outcome = parseInt(document.getElementById(`outcome-${marketId}`).value);
            const amount = parseFloat(document.getElementById(`amount-${marketId}`).value);

            if (!amount || amount < 0.001) {
                showMessage('Minimum bet is 0.001 BNB', 'error');
                return;
            }

            try {
                // Get contract address from API or use default
                if (!contractAddress) {
                    const configResponse = await fetch('/api/config');
                    const config = await configResponse.json();
                    contractAddress = config.contractAddress;
                    
                    if (!contractAddress) {
                        // Fallback: try to get from market data
                        const marketResponse = await fetch(`/api/markets/${marketId}`);
                        const marketData = await marketResponse.json();
                        if (marketData.market && marketData.market.chainData) {
                            // Contract might be in chainData
                        }
                        
                        // Contract is required
                        showMessage('Contract not deployed. Please deploy contract first.', 'error');
                        return;
                    }
                }

                // Connect to contract via MetaMask
                const provider = new ethers.BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();
                const contract = new ethers.Contract(contractAddress, CONTRACT_ABI, signer);

                // Convert BNB amount to wei
                const amountWei = ethers.parseEther(amount.toString());

                showMessage('Confirm transaction in MetaMask...', 'success');

                // Call contract placeBet function
                const tx = await contract.placeBet(marketId, outcome, { value: amountWei });
                
                showMessage(`Transaction sent! Hash: ${tx.hash}`, 'success');
                showMessage('Waiting for confirmation...', 'success');

                // Wait for transaction confirmation
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    showMessage('Bet placed successfully on-chain!', 'success');
                    
                    // Bet is now on-chain, no API sync needed
                    console.log('Bet confirmed on-chain:', receipt.hash);
                    
                    loadMarkets();
                } else {
                    showMessage('Transaction failed', 'error');
                }
            } catch (error) {
                if (error.code === 4001) {
                    showMessage('Transaction rejected by user', 'error');
                } else if (error.code === -32603) {
                    showMessage('Contract error: ' + error.message, 'error');
                } else {
                    showMessage('Error: ' + error.message, 'error');
                }
            }
        }

        // No off-chain betting - contract is required

        // Show message
        function showMessage(message, type) {
            const messagesDiv = document.getElementById('messages');
            const msgDiv = document.createElement('div');
            msgDiv.className = type;
            msgDiv.textContent = message;
            messagesDiv.appendChild(msgDiv);
            
            setTimeout(() => {
                msgDiv.remove();
            }, 5000);
        }

        // Auto-connect if already connected
        if (typeof window.ethereum !== 'undefined') {
            window.ethereum.request({ method: 'eth_accounts' }).then(accounts => {
                if (accounts.length > 0) {
                    userAddress = accounts[0];
                    document.getElementById('wallet-address').textContent = 
                        userAddress.substring(0, 6) + '...' + userAddress.substring(38);
                    loadMarkets();
                }
            });
        }

        // Load markets on page load
        loadMarkets();
    </script>
</body>
</html>

